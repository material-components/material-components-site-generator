#!/usr/bin/env node

const assert = require('assert');
const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
const reporter = require('./lib/reporter');
const webpack = require('webpack');
const { BuildDir } = require('./lib/conf');
const { execSync } = require('child_process');
const { isJekyllIndex, isJekyllMarkdown, liquifyMarkdown, renameJekyllToIndex } = require('./lib/jekyll');
const { sync: globSync } = require('glob');



// Validate input
const args = process.argv.slice(2);
if (args.length == 0) {
  console.error('Missing path to components repo.\n' +
                'Usage: script/build path/to/mdc/repo');
  process.exit(1);
}

const basePath = args[0];
const basePathStat = fs.lstatSync(basePath);
if (!basePathStat.isDirectory()) {
  console.error('Path argument must point to a directory.\n' +
                'Usage: script/build path/to/mdc/repo');
  process.exit(1);
}

// Ensure that the working directory is the project root
const projectRootPath = path.join(__dirname, '..');
process.chdir(projectRootPath);

// Check prerequisites
reporter.step('Checking dependencies...', () => {
  for (let pkgManager of ['bundle', 'yarn']) {
    try {
      execSync(`${pkgManager} check`);
    } catch(e) {
      console.error(`Dependencies not met. Please run ${pkgManager} install.`);
      process.exit(1);
    }
  }
});

// Clean
reporter.step('Cleaning...', () => {
  try {
    assert(process.cwd() == projectRootPath);
    fs.removeSync(BuildDir.STAGE);
    fs.removeSync(BuildDir.DIST);
  } catch(e) {
    console.error(chalk.red('Something went wrong'));
    console.error(e);
    process.exit(1);
  }
});

// Clone Jekyll source
fs.copySync(BuildDir.JEKYLL, BuildDir.STAGE);


// Prepare markdown
const jekyllMarkdownFiles =
reporter.step('Finding Jekyll markdown...', () => {
  const markdownFiles = globSync(path.join(basePath, '**/*.md'))
      .map((filePath) => readTextFile(filePath, basePath))
  return markdownFiles.filter(isJekyllMarkdown);
}, { noCheck: true });

reporter.step('Liquifying ðŸ’¦ ...', () => {
  jekyllMarkdownFiles.forEach(liquifyMarkdown);
});

reporter.step('Creating indexes...', () => {
  jekyllMarkdownFiles
      .filter(isJekyllIndex)
      .forEach(renameJekyllToIndex);
});

reporter.step('Copying files...', () => {
  jekyllMarkdownFiles.forEach((file) => {
    const { contents, encoding, relativePath } = file;
    const newPath = path.resolve(BuildDir.STAGE, relativePath);
    fs.ensureDirSync(path.dirname(newPath));
    fs.writeFileSync(newPath, contents, { encoding });
  });

  globSync(path.join(basePath, '**/docs/'))
      .forEach((docsDirPath) => {
        const relativePath = path.relative(basePath, docsDirPath);
        const newPath = path.resolve(BuildDir.STAGE, relativePath);
        fs.ensureDirSync(newPath);
        fs.copySync(docsDirPath, newPath);
      });
});

reporter.step('Building Jekyll site...', () => {
  const jekyllEnv = Object.assign({}, process.env, {
    BUNDLE_GEMFILE: path.join(projectRootPath, 'GEMFILE'),
  });
  execSync(`bundle exec jekyll build \
      --source ${BuildDir.STAGE} \
      --destination ${BuildDir.DIST} \
      --config ${path.join(BuildDir.STAGE, '_config.yml')}`,
    {
      env: jekyllEnv,
      stdio: 'inherit',
    });
}, { noCheck: true });

reporter.step('Building assets...', () => {
  webpack(require('../webpack.config'), (err, stats) => {
    if (err) {
      reporter.fatal(err);
      process.exit(1);
    } else if (stats.hasWarnings()) {
      reporter.webpackStats(stats);
    } else if (stats.hasErrors()) {
      reporter.webpackStats(stats);
      process.exit(1);
    }

    reporter.complete();
  });
}, { noCheck: true });



function readTextFile(path, basePath) {
  return readFile(path, basePath, 'utf8');
}

function readFile(filePath, basePath, encoding=null) {
  // We could use a vinyl file here.
  return {
    path: filePath,
    basePath,
    encoding,
    relativePath: path.relative(basePath, filePath),
    contents: fs.readFileSync(filePath, { encoding }),
  };
}

function writeFile(file) {
  const { path, encoding, contents } = file;
  fs.writeFileSync(path, contents, { encoding });
}
